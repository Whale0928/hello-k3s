# Phase 4: Secret 기초
# 민감한 정보 안전하게 관리하기

# 1. 기본 Secret (Opaque 타입)
apiVersion: v1
kind: Secret
metadata:
  name: app-secret
  namespace: test-namespace
type: Opaque
data:
  # base64로 인코딩된 값
  # echo -n 'admin' | base64 = YWRtaW4=
  # echo -n 'mypassword' | base64 = bXlwYXNzd29yZA==
  username: YWRtaW4=
  password: bXlwYXNzd29yZA==

---
# 2. stringData로 쉽게 생성 (자동 인코딩)
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
  namespace: test-namespace
type: Opaque
stringData:
  # 평문으로 작성 (자동으로 base64 인코딩됨)
  database-url: "mysql://localhost:3306/mydb"
  database-user: "dbuser"
  database-password: "secretpass123"

---
# 3. Secret을 환경변수로 사용
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-with-secret
  namespace: test-namespace
spec:
  replicas: 1
  selector:
    matchLabels:
      app: secret-demo
  template:
    metadata:
      labels:
        app: secret-demo
    spec:
      containers:
      - name: app
        image: busybox
        command: ['sh', '-c', 'echo "User: $DB_USER connected" && sleep 3600']
        env:
        # Secret에서 개별 값 가져오기
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: app-secret
              key: username
        - name: DB_PASS
          valueFrom:
            secretKeyRef:
              name: app-secret
              key: password
        # 전체 Secret을 환경변수로
        envFrom:
        - secretRef:
            name: db-secret

---
# 4. Secret을 Volume으로 마운트
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-with-secret-volume
  namespace: test-namespace
spec:
  replicas: 1
  selector:
    matchLabels:
      app: secret-volume-demo
  template:
    metadata:
      labels:
        app: secret-volume-demo
    spec:
      containers:
      - name: app
        image: nginx:alpine
        volumeMounts:
        - name: secret-volume
          mountPath: /etc/secrets
          readOnly: true
      volumes:
      - name: secret-volume
        secret:
          secretName: app-secret
          # 파일 권한 설정
          defaultMode: 0400

---
# 5. TLS Secret 예제
apiVersion: v1
kind: Secret
metadata:
  name: tls-secret
  namespace: test-namespace
type: kubernetes.io/tls
data:
  # 실제로는 인증서 파일을 base64 인코딩
  # kubectl create secret tls tls-secret --cert=tls.crt --key=tls.key
  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi4uLgotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0t
  tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi4uLgotLS0tLUVORCBQUklWQVRFIEtFWS0tLS0t

---
# Secret 테스트 가이드
apiVersion: v1
kind: ConfigMap
metadata:
  name: secret-guide
  namespace: test-namespace
data:
  guide.txt: |
    # Secret 테스트
    
    1. Secret 확인
    kubectl get secrets -n test-namespace
    kubectl describe secret app-secret -n test-namespace
    
    2. Secret 값 디코딩
    kubectl get secret app-secret -n test-namespace -o jsonpath='{.data.username}' | base64 -d
    
    3. 환경변수 확인
    kubectl exec -it deployment/app-with-secret -n test-namespace -- env | grep DB
    
    4. 마운트된 파일 확인
    kubectl exec -it deployment/app-with-secret-volume -n test-namespace -- ls -la /etc/secrets
    kubectl exec -it deployment/app-with-secret-volume -n test-namespace -- cat /etc/secrets/username
    
    5. Secret 생성 명령어
    # 파일에서 생성
    echo -n 'admin' > username.txt
    echo -n 'password' > password.txt
    kubectl create secret generic my-secret --from-file=username.txt --from-file=password.txt
    
    # 명령어로 생성
    kubectl create secret generic my-secret2 --from-literal=user=admin --from-literal=pass=secret
    
    주의: Secret은 base64 인코딩일 뿐, 암호화가 아님!
    프로덕션에서는 Sealed Secrets, Vault 등 사용 권장
