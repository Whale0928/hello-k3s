# 워커 노드 (Worker Node) 이해하기

## 워커 노드란?

워커 노드는 실제 애플리케이션이 실행되는 **일꾼** 서버입니다. 마스터 노드가 두뇌라면, 워커 노드는 손발이라고 할 수 있습니다.

```
비유:
마스터 노드 = 요리사 (레시피 결정)
워커 노드 = 조리대와 오븐 (실제 요리)
파드 = 요리되는 음식

요리사가 지시하면 조리대에서 실제 요리가 만들어지듯
마스터가 지시하면 워커 노드에서 파드가 실행됨
```

---

## 워커 노드의 구성 요소

워커 노드는 3개의 핵심 컴포넌트로 구성됩니다.

```
┌──────────────────────────────────────┐
│           Worker Node                │
├──────────────────────────────────────┤
│                                      │
│  ┌────────────────────────────────┐  │
│  │          kubelet               │  │
│  │  (파드 실행 및 관리)            │  │
│  └────────────────────────────────┘  │
│                                      │
│  ┌────────────────────────────────┐  │
│  │         kube-proxy             │  │
│  │  (네트워크 프록시)              │  │
│  └────────────────────────────────┘  │
│                                      │
│  ┌────────────────────────────────┐  │
│  │     Container Runtime          │  │
│  │  (Docker/containerd/CRI-O)     │  │
│  └────────────────────────────────┘  │
│                                      │
│  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐   │
│  │Pod A│ │Pod B│ │Pod C│ │Pod D│   │
│  └─────┘ └─────┘ └─────┘ └─────┘   │
└──────────────────────────────────────┘
```

---

## kubelet - 노드의 에이전트

### 역할과 책임

kubelet은 각 워커 노드에서 실행되는 **에이전트**로, 마스터의 지시를 받아 실제 작업을 수행합니다.

**주요 기능:**
- 파드 생성, 시작, 중지, 삭제
- 컨테이너 상태 모니터링
- 헬스 체크 수행
- 리소스 사용량 보고
- 볼륨 마운트 관리

### kubelet 동작 과정

```
1. API Server에서 파드 할당 확인
       ↓
2. 컨테이너 이미지 다운로드
       ↓
3. 컨테이너 런타임에 실행 요청
       ↓
4. 파드 네트워크 설정
       ↓
5. 볼륨 마운트
       ↓
6. 컨테이너 시작
       ↓
7. 상태 지속 모니터링 및 보고
```

### 실제 동작 예시

```bash
# 마스터: "nginx 파드를 node2에서 실행해"
# kubelet@node2의 동작:

1. 이미지 확인
   docker pull nginx:latest

2. 컨테이너 생성
   docker create --name nginx-pod nginx:latest

3. 네트워크 설정
   CNI 플러그인 호출

4. 컨테이너 시작
   docker start nginx-pod

5. 상태 보고
   "파드 Running 상태입니다" → API Server
```

### kubelet 설정

```yaml
# kubelet 주요 설정
--max-pods=110              # 최대 파드 수
--pod-infra-container-image # pause 컨테이너 이미지
--cluster-dns=10.43.0.10   # 클러스터 DNS
--cluster-domain=cluster.local
--container-runtime=containerd
--cgroup-driver=systemd
```

---

## kube-proxy - 네트워크 마법사

### 역할과 책임

kube-proxy는 각 노드에서 실행되며 **네트워크 규칙을 관리**합니다. Service를 통한 파드 접근을 가능하게 합니다.

### 동작 모드

**1. iptables 모드 (기본)**
```
Service (ClusterIP: 10.96.0.1)
         ↓
    iptables 규칙
         ↓
   ┌──────┴──────┬──────────┐
   Pod1       Pod2        Pod3
   (10.244.1.5) (10.244.2.8) (10.244.3.11)
```

**2. IPVS 모드 (고성능)**
```
더 효율적인 로드밸런싱
- Round Robin
- Least Connection  
- Source Hashing
```

### Service 종류별 동작

**ClusterIP Service**
```bash
# 클러스터 내부에서만 접근
curl 10.96.0.1:80
# kube-proxy가 실제 파드로 전달
→ 10.244.1.5:80 (Pod IP)
```

**NodePort Service**
```bash
# 외부에서 노드 IP로 접근
curl 192.168.1.100:30080
# kube-proxy가 처리
→ 10.96.0.1:80 (Service)
→ 10.244.1.5:80 (Pod)
```

**LoadBalancer Service**
```bash
# 클라우드 로드밸런서 통합
External LB → NodePort → Service → Pod
```

---

## Container Runtime - 컨테이너 실행 엔진

### 지원되는 런타임

```
┌─────────────────────────────────────┐
│     Container Runtime Interface      │
├─────────────────────────────────────┤
│                                     │
│  ┌─────────┐  ┌──────────┐  ┌──────┐│
│  │ Docker  │  │containerd│  │CRI-O ││
│  └─────────┘  └──────────┘  └──────┘│
│                                     │
│  최근 트렌드: containerd 사용 증가   │
│  K3s 기본: containerd               │
└─────────────────────────────────────┘
```

### 런타임별 특징

**Docker**
```
장점: 친숙함, 많은 도구
단점: 무겁다, 불필요한 기능 많음
상태: Kubernetes 1.24부터 지원 중단
```

**containerd**
```
장점: 가볍다, 빠르다, 안정적
단점: Docker CLI 미지원
상태: 현재 표준 (K3s 기본)
```

**CRI-O**
```
장점: 최소한의 기능, 보안 중심
단점: 생태계 작음
상태: OpenShift 기본
```

### 컨테이너 실행 과정

```
1. kubelet → CRI 요청
       ↓
2. 이미지 레지스트리에서 Pull
       ↓
3. 이미지 레이어 추출
       ↓
4. 컨테이너 생성
   - Namespace 격리
   - Cgroup 리소스 제한
   - 파일시스템 마운트
       ↓
5. 프로세스 시작
```

---

## 워커 노드의 파드 실행 과정

### 전체 플로우

```
마스터 노드                    워커 노드
API Server  ──────────────►  kubelet
    │                            │
    │                            ▼
Scheduler                   Container Runtime
    │                            │
    │                            ▼
    └──────► 파드 할당      실제 컨테이너 실행
                                 │
                                 ▼
                            kube-proxy
                          (네트워크 설정)
```

### 상세 단계

**1. 파드 생성 요청**
```yaml
kubectl apply -f nginx-pod.yaml
```

**2. 스케줄링**
```
Scheduler: "node2가 리소스 여유 있네"
API Server: "node2의 kubelet에게 전달"
```

**3. kubelet 실행**
```bash
# node2의 kubelet
1. 파드 스펙 수신
2. 이미지 다운로드
3. 컨테이너 생성
4. 네트워크 구성
5. 실행 및 모니터링
```

---

## 워커 노드 리소스 관리

### 노드 용량 (Capacity)

```bash
kubectl describe node worker-1

Capacity:
  cpu:                4       # 전체 CPU
  memory:             16Gi    # 전체 메모리
  ephemeral-storage:  100Gi  # 전체 디스크
  pods:               110     # 최대 파드 수

Allocatable:
  cpu:                3.8     # 사용 가능 CPU
  memory:             15Gi    # 사용 가능 메모리
  pods:               110
```

### 리소스 요청과 제한

```yaml
# 파드 리소스 설정
resources:
  requests:     # 최소 보장
    memory: "256Mi"
    cpu: "250m"
  limits:       # 최대 사용
    memory: "512Mi"
    cpu: "500m"
```

### 리소스 할당 예시

```
노드 총 메모리: 16GB
시스템 예약: 1GB
━━━━━━━━━━━━━━━━━━━
사용 가능: 15GB

파드 A: 2GB (요청)
파드 B: 1GB (요청)
파드 C: 4GB (요청)
━━━━━━━━━━━━━━━━━━━
남은 용량: 8GB

새 파드 (10GB 요청) → 스케줄링 실패!
```

---

## 워커 노드 네트워킹

### 파드 네트워크

```
각 파드는 고유 IP 보유
┌─────────────────────────────┐
│      Node (192.168.1.10)    │
├─────────────────────────────┤
│                             │
│  Pod A         Pod B        │
│  10.244.1.2    10.244.1.3   │
│                             │
│  가상 네트워크 브리지         │
│  (cbr0 or cni0)            │
└─────────────────────────────┘
```

### CNI 플러그인

**Flannel (K3s 기본)**
```
간단한 오버레이 네트워크
VXLAN 또는 host-gw 모드
설정 간단, 성능 적당
```

**Calico**
```
고급 네트워크 정책 지원
BGP 라우팅
대규모 클러스터 적합
```

**Weave**
```
암호화 지원
멀티캐스트 지원
설정 매우 간단
```

---

## 워커 노드 스토리지

### 컨테이너 레이어

```
┌─────────────────────────┐
│   Container Layers      │
├─────────────────────────┤
│  쓰기 가능 레이어 (최상위) │
├─────────────────────────┤
│  애플리케이션 레이어      │
├─────────────────────────┤
│  라이브러리 레이어        │
├─────────────────────────┤
│  베이스 이미지 (읽기전용)  │
└─────────────────────────┘
```

### 볼륨 타입

**emptyDir**
```yaml
# 파드 생명주기와 동일
volumes:
- name: cache-volume
  emptyDir: {}
```

**hostPath**
```yaml
# 노드 파일시스템 마운트
volumes:
- name: host-volume
  hostPath:
    path: /data
```

**PersistentVolume**
```yaml
# 영구 스토리지
persistentVolumeClaim:
  claimName: my-pvc
```

---

## 워커 노드 모니터링

### 핵심 메트릭

```bash
# 노드 리소스 사용량
kubectl top node worker-1
NAME       CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%
worker-1   812m         20%    4328Mi          28%

# 파드별 리소스 사용량
kubectl top pods --all-namespaces
NAMESPACE   NAME           CPU    MEMORY
default     nginx-xxx      10m    20Mi
default     mysql-xxx      100m   500Mi
```

### 모니터링 지표

**kubelet 메트릭**
```
- 파드 시작/정지 횟수
- 컨테이너 재시작 횟수
- 이미지 풀 시간
- 볼륨 마운트 실패
```

**시스템 메트릭**
```
- CPU 사용률
- 메모리 사용량
- 디스크 I/O
- 네트워크 트래픽
```

---

## 워커 노드 보안

### 노드 격리

```
Taint와 Toleration으로 특정 파드만 실행
┌────────────────────────────────┐
│  GPU 노드 (taint: gpu=true)    │
│  → GPU 파드만 스케줄링          │
└────────────────────────────────┘
```

### 보안 설정

**1. 노드 접근 제한**
```bash
# SSH 키 인증만 허용
# 불필요한 포트 차단
# 정기 보안 업데이트
```

**2. 컨테이너 보안**
```yaml
securityContext:
  runAsNonRoot: true
  readOnlyRootFilesystem: true
  capabilities:
    drop: ["ALL"]
```

---

## 워커 노드 추가하기

### 일반 Kubernetes

```bash
# 1. 노드 준비
apt-get update
apt-get install -y kubelet kubeadm kubectl

# 2. 클러스터 조인
kubeadm join 192.168.1.100:6443 \
  --token abcdef.1234567890abcdef \
  --discovery-token-ca-cert-hash sha256:...
```

### K3s 방식

```bash
# 매우 간단!
curl -sfL https://get.k3s.io | \
  K3S_URL=https://192.168.1.100:6443 \
  K3S_TOKEN=mynodetoken \
  sh -

# 끝! 자동으로 클러스터 조인
```

---

## 워커 노드 트러블슈팅

### 노드 NotReady 상태

```bash
# 1. kubelet 상태 확인
systemctl status kubelet
journalctl -u kubelet -f

# 2. 네트워크 플러그인 확인
kubectl get pods -n kube-system

# 3. 디스크 공간 확인
df -h
```

### 파드 스케줄링 안 됨

```bash
# 1. 노드 리소스 확인
kubectl describe node worker-1

# 2. Taint 확인
kubectl get nodes -o json | jq '.items[].spec.taints'

# 3. 노드 라벨 확인
kubectl get nodes --show-labels
```

### 네트워크 문제

```bash
# 1. kube-proxy 확인
kubectl logs -n kube-system kube-proxy-xxx

# 2. iptables 규칙 확인
iptables -t nat -L -n -v

# 3. CNI 플러그인 확인
ls -la /etc/cni/net.d/
```

---

## K3s 에이전트 (워커 노드)

### K3s의 간소화

```
일반 K8s 워커:
kubelet + kube-proxy + containerd (개별 설치)

K3s 에이전트:
k3s agent (모든 것 포함)
```

### K3s 에이전트 특징

```bash
# 설치 한 줄
curl -sfL https://get.k3s.io | K3S_URL=... sh -

# 자동 포함
- kubelet
- kube-proxy  
- flannel CNI
- containerd
- 기본 설정
```

---

## 워커 노드 베스트 프랙티스

### 리소스 계획

```
1. 시스템 예약 공간 확보 (10-20%)
2. 파드 리소스 requests 필수 설정
3. limits는 requests의 2배 이내
4. 노드당 파드 수 제한 고려
```

### 노드 관리

```
1. 정기적인 노드 재부팅 (월 1회)
2. 자동 노드 업데이트 설정
3. 노드 드레인 후 유지보수
4. 로그 로테이션 설정
```

### 모니터링

```
1. 노드 리소스 80% 경고
2. 파드 재시작 횟수 모니터링
3. 디스크 공간 자동 정리
4. 네트워크 지연 시간 체크
```

---

## 요약

워커 노드는 실제 애플리케이션이 실행되는 **일꾼 서버**입니다.

**핵심 컴포넌트:**
- **kubelet**: 파드 실행 및 관리
- **kube-proxy**: 네트워크 프록시
- **Container Runtime**: 컨테이너 실행

**중요 포인트:**
- 하나의 노드에 수십~수백 개 파드 실행 가능
- 리소스 관리가 핵심 (CPU, 메모리, 디스크)
- K3s는 이 모든 걸 자동으로 설정

다음 문서에서는 실제로 **K3s를 설치**하고 첫 클러스터를 구축해보겠습니다!